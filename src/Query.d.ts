import { ClickHouse } from 'clickhouse';
import { Expression } from './Expression';
import { Logger } from 'winston';
type Operator = '=' | '<' | '>' | '>=' | '<=' | '!=' | 'BETWEEN' | 'IN' | 'NOT IN' | 'LIKE' | 'NOT LIKE' | 'IS NULL' | 'IS NOT NULL';
type WhereValueCondition = string | number | [string, string] | [number, number] | number[] | string[] | Expression | null;
type WhereGroupConditions = 'AND' | 'OR';
type Selectable = Array<string | String | Query> | string;
type SelectParams = Selectable | '*';
type OrderBy = [string, 'ASC' | 'DESC'];
type JoinOperator = 'JOIN' | 'INNER JOIN' | 'LEFT OUTER JOIN' | 'RIGHT OUTER JOIN' | 'FULL OUTER JOIN' | 'CROSS JOIN' | 'LEFT SEMI JOIN' | 'RIGHT SEMI JOIN' | 'LEFT ANTI JOIN' | 'RIGHT ANTI JOIN' | 'LEFT ANY JOIN' | 'RIGHT ANY JOIN' | 'INNER ANY JOIN' | 'ASOF JOIN' | 'LEFT ASOF JOIN';
export declare class Query {
    private readonly connection;
    private readonly logger;
    private withPart;
    private selectPart;
    private fromPart;
    private wherePart;
    private groupByPart;
    private orderByPart;
    private limitPart;
    private offsetPart;
    private joinPart;
    private aliasPart;
    constructor(ch: ClickHouse, logger: Logger);
    with(params: Selectable): this;
    select(params: SelectParams): this;
    as(alias: string): this;
    from(table: string | Query, alias?: string | null): this;
    where(column: string | Expression, operator?: Operator | null, value?: WhereValueCondition): this;
    andWhere(column: string | Expression, operator?: Operator | null, value?: WhereValueCondition): this;
    orWhere(column: string | Expression, operator?: Operator | null, value?: WhereValueCondition): this;
    andWhereGroup(groupOperator: WhereGroupConditions, conditions: Array<[column: string, operator: Operator | null, value: WhereValueCondition]>): this;
    orWhereGroup(groupOperator: WhereGroupConditions, conditions: Array<[column: string, operator: Operator | null, value: WhereValueCondition]>): this;
    join(operator: JoinOperator, query: Query, alias: string, on: string): this;
    offset(offset: number | string): this;
    limit(limit: number | string): this;
    groupBy(columns: Array<string>): this;
    orderBy(params: Array<OrderBy>): this;
    clone(): Query;
    generateSql(): string;
    private buildWhereCondition;
    execute<Response extends Object[]>(params?: Record<string, string | number | undefined>): Promise<Response>;
    private replaceParamsWithValues;
}
export {};
